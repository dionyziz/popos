\section{Preliminaries}

\noindent
\emph{Notation.}
We use $\epsilon$ to mean the empty string and $[\,]$ to mean the empty sequence.
By $x \concat y$ we mean the string concatenation
of $x$ and $y$ encoded in a way that $x$ and $y$ can be unambiguously retrieved.
We denote $|\chain|$ the length of the sequence $\chain$; by $\chain[i]$ the $i^\text{th}$ (zero-based)
element of the sequence, and by $\chain[-i]$ the $i^\text{th}$ element from the end.
We use $\chain[i{:}j]$ to mean the subarray of $\chain$ from the $i^\text{th}$ element
(inclusive) to the $j^\text{th}$ element (exclusive). Omitting $i$ takes the sequence
to the beginning, and omitting $j$ takes the sequence to the end. 

We use $\{ \textsf{key} \Rightarrow \textsf{value}, \cdots \}$ to denote a dictionary (hashmap)
containing the denoted key/value pairs and $\{\,\}$ to denote the empty dictionary. A dictionary
can be read and written by accessing it using the notation $d[\textsf{key}]$ and, if a key is
in the dictionary, then $\textsf{key} \in d$ is $\true$. Two dictionaries
can be combined using the $A \cup B$ operator, in which case keys in $A$ are overwritten in
case they are also defined in $B$. We use $s\restriction_2$ to mean a string interpreted as
a binary number. For example, if $s = ``00110''$, then $s\restriction_2 = 6$.

\noindent
\emph{Proof-of-stake.}
For concreteness
we present our construction in
\emph{Ouroboros}~\cite{ouroboros}, a provably secure proof-of-stake protocol.
As we discuss in Section~\ref{sec.other},
our results
are not Ouroboros-specific and can be directly adapted to any modern proof-of-stake
system such as Snow White~\cite{snowwhite} and Algorand~\cite{algorand}.

We assume a \emph{synchronous network} and divide time into \emph{slots}. At every
slot, a \emph{leader} is elected to produce a \emph{block}. Each block follows the
standard blockchain structure of referencing its previous block. Every honest party
maintains a \emph{chain} $\chain$, which is a sequence of blocks. When multiple chains
are
available, the honest party uses the \emph{longest chain rule} to choose the longest
valid one. An honest leader always mints a block on top of its currently adopted chain.
The adversary can either refrain from minting a block in the slot she is designated
leader, or produce multiple blocks during that slot, causing temporary chain \emph{forks}.
She can also produce blocks for that slot at a later or earlier time than allocated.
The block $\chain[0]$
is called the \emph{genesis} block, and it is a hard-coded value. The block $\chain[-1]$
is the \emph{tip}.

Blocks contain \emph{transactions} that transfer stake from one party to another.
A central assumption is that \emph{the stake majority is honest} at any point in
time.

The chains adopted by the protocol satisfy the \emph{Common Prefix} property
with a parameter $k \in \mathbb{N}$:
Consider any two chains $\chain_1$ and $\chain_2$ adopted by two honest parties
during the same slot. Then $\chain_1[{:}-k]$ is a prefix of $\chain_2$.
Blocks included in $\chain[{:}-k]$ of any party will never be abandoned,
so this is called the \emph{stable} part of the chain. Transactions included
in the stable part of the chain are called \emph{confirmed}.

Slots are split into \emph{epochs} consisting of $\mathcal{R} = 12k$
slots~\cite{pos-sidechains} each\footnote{In Ouroboros~\cite{ouroboros},
the system is proven secure for epoch length $\mathcal{R} \geq 10k$.
The $2k$ extra slots will
be useful once we develop the full protocol in Section~\ref{sec.compression}}.
Although money can still be transferred, a stake distribution \emph{snapshot} $\textsf{SD}_j$
is taken on the $4k^\text{th}$ slot of each epoch $j-1$. This distribution is
used for the leader election of epoch $j$. Additionally, during epoch $j-1$, some fresh
uniformly distributed randomness $\eta_j$ is generated by the parties using a \emph{guaranteed-delivery
coin tossing protocol}. This randomness is used to sample the leaders for epoch
$j$. The sampling is performed such that the probability of being selected leader
for a slot is proportional to the stake one holds.

The proof-of-stake system is resilient to a \emph{semi-adaptive adversary} who can
choose to corrupt honest parties after a fixed delay of two epochs. This is necessary
because the leaders of the previous epochs are still trusted at the time a new epoch
starts. To protect against a future corruption, an honest party \emph{rotates} his
key after producing a block, erasing the secret key that can be used for block
production for the particular slot (of course, the adversary may refrain from doing
this).

A central result in the Ouroboros proof-of-stake system is the \emph{honest subsequence}
lemma: Consider any continuous window of $2k$ slots within an epoch. If \emph{any}
$k+1$ keys among these $2k$ are chosen, then at least one of them is guaranteed to
be honest, except with negligible probability in $k$
(the proof follows easily from the \emph{persistence} property of
Ouroboros~\cite{ouroboros}, c.f., Lemma $6$ in~\cite{pos-sidechains}).

\noindent
\emph{Merkle trees.} A Merkle tree~\cite{merkle} is a standard authenticated data structure
in which an array of data is organized into a binary tree. The data structure is built on
top of a secure hash function $H$. Initially, each leaf of data is hashed on its own. These hashes
form the leaves of the tree. Each odd-numbered leaf $h_1$ is then paired with its adjacent even-numbered
leaf $h_2$ and their values are concatenated and hashed together to form their parent
$h = H(h_1 \concat h_2)$. This process continues until we arrive at a single \emph{Merkle tree root}.
If a verifier holds this root, a prover who wishes to illustrate that a leaf at a given index $b$
has a particular value simply provides the siblings along the path from the leaf to the root.
The verifier uses these siblings to calculate a new hash iteratively from the data until it
arrives at the root. Since the path is logarithmic in the count of the leaves, these proofs are
succinct. For the security of Merkle trees, only the \emph{collision resistance} property of hash
functions is needed (contrary to proof-of-work constructions, we can work in the \emph{standard model}
and do not model the hash function as a \emph{random oracle}). This ensures that no prover can
convincingly claim that a leaf is in a particular position in a tree that was constructed with different
data in that same position. Nodes in a Merkle tree are referenced by a binary string whose
length denotes the node depth. The root is referenced by the empty string $\epsilon$, the
left child of the root is referenced by $0$, the right child of the root is referenced by
$1$, the left child of the lift child is referenced by $00$ and so forth.
