\section{Preliminaries}

\noindent
\emph{Notation.}
We use $\epsilon$ to mean the empty string and $[\,]$ to mean the empty sequence.
By $x \concat y$ we mean the string concatenation
of $x$ and $y$ encoded in a way that $x$ and $y$ can be unambiguously retrieved.
We denote $|\chain|$ the length of the sequence $\chain$; by $\chain[i]$ the $i^\text{th}$ (zero-based)
element of the sequence, and by $\chain[-i]$ the $i^\text{th}$ element from the end.
We use $\chain[i{:}j]$ to mean the subarray of $\chain$ from the $i^\text{th}$ element
(inclusive) to the $j^\text{th}$ element (exclusive). Omitting $i$ takes the sequence
to the beginning, and omitting $j$ takes the sequence to the end. 

We use $\{ \textsf{key} \Rightarrow \textsf{value}, \cdots \}$ to denote a dictionary (hashmap)
containing the denoted key/value pairs and $\{\,\}$ to denote the empty dictionary. A dictionary
can be read and written by accessing it using the notation $d[\textsf{key}]$ and, if a key is
in the dictionary, then $\textsf{key} \in d$ is $\true$. Two dictionaries
can be combined using the $A \cup B$ operator, in which case keys in $A$ are overwritten in
case they are also defined in $B$. We use $s\restriction_2$ to mean a string interpreted as
a binary number. For example, if $s = $ ``00110'', then $s\restriction_2 = 6$.

\noindent
\emph{Proof-of-stake.}
For concreteness
we present our construction in
\emph{Ouroboros}~\cite{ouroboros}, a provably secure proof-of-stake protocol.
As we discuss in Section~\ref{sec.other},
our results
are not Ouroboros-specific and can be directly adapted to any modern proof-of-stake
system such as Snow White~\cite{snowwhite} and Algorand~\cite{algorand}.

We assume a \emph{synchronous network} and divide time into \emph{slots}. At every
slot, a \emph{leader} is elected to produce a \emph{block}. Each block follows the
standard blockchain structure of referencing its previous block. Every honest party
maintains a \emph{chain} $\chain$, which is a sequence of blocks. When multiple chains
are
available, the honest party uses the \emph{longest chain rule} to choose the longest
valid one. An honest leader always mints a block on top of its currently adopted chain.
The adversary can either refrain from minting a block in the slot she is designated
leader, or produce multiple blocks during that slot, causing temporary chain \emph{forks}.
She can also produce blocks for that slot at a later or earlier time than allocated.
The block $\mathcal{G} = \chain[0]$
is called the \emph{genesis} block, and it is a hard-coded value. The block $\chain[-1]$
is the \emph{tip}.

A block $b$ contains \emph{transactions} $b\textsf{.txs}$ that transfer stake from one party to another.
For efficiency, blocks do not directly contain the transaction data. Instead, $b\textsf{.txs}$
is a Merkle tree (see below) for which a proof-of-inclusion can be provided.
A chain that includes only the block headers is known as a \emph{header chain}.
In the \emph{Simple Payment Verification} (SPV~\cite{bitcoin}) protocol, a client
processes a header chain without processing all transactions.

A central assumption is that \emph{the stake majority is honest} at any point in
time.

The chains adopted by the protocol satisfy the \emph{Common Prefix} property
with a parameter $k \in \mathbb{N}$:
Consider any two chains $\chain_1$ and $\chain_2$ adopted by two honest parties
during the same slot. Then $\chain_1[{:}-k]$ is a prefix of $\chain_2$.
Blocks included in $\chain[{:}-k]$ of any party will never be abandoned,
so this is called the \emph{stable} part of the chain. We will call a
transaction \emph{confirmed} if it included in the stable part of the
chain of all honest parties, and at least $2k$ slots have passed since
the production of the block in which it is included.

Slots are split into \emph{epochs} consisting of $\mathcal{R} = 16k$
slots~\cite{pos-sidechains} each\footnote{In Ouroboros~\cite{ouroboros},
the system is proven secure for epoch length $\mathcal{R} \geq 10k$.
The $6k$ extra slots will
be useful once we develop our protocol in Section~\ref{sec.handover}.}.
We denote by $S_j$ the sequence of slots in epoch $j$.
Although money can still be transferred, a stake distribution \emph{snapshot} $\textsf{SD}_j$
is taken at the slot $S_{j-1}[-8k]$ of each epoch $j-1$. This distribution is
used for the leader election of epoch $j$. Additionally, during epoch $j-1$, some fresh
uniformly distributed randomness $\eta_j$ is generated by the parties using a \emph{guaranteed-delivery
coin tossing protocol}. This randomness is used to sample the leaders for epoch
$j$. The sampling is performed such that the probability of being selected leader
for a slot is proportional to the stake one holds. The randomness $\eta_j$ is available
during the last $6k$ slots of epoch $j-1$. 

The proof-of-stake system is resilient to a \emph{semi-adaptive adversary} who can
choose to corrupt honest parties after a fixed delay of two epochs. This is necessary
because the leaders of the previous epoch are still trusted at the time a new epoch
starts. To protect against a future corruption, an honest party \emph{rotates} his
key after producing a block, erasing the secret key that can be used for block
production for the particular slot (of course, the adversary may refrain from doing
this).

We will make use of the fact that the chain grows at a rate with a
particular lower bound:

\begin{lemma}[Chain growth]\label{lem.growth}
Consider any $2k$ consecutive slots in an execution.
At least $k+1$ blocks will have been generated therein, except with negligible
probability in $k$.
\end{lemma}

For the precise parametrization required for this lemma, and the nuances between
Honest Chain Growth and Chain Growth, refer to Theorem 5.3 in~\cite{ouroboros}.

A central result in the Ouroboros proof-of-stake system is the \emph{honest subsequence}
lemma:

\begin{lemma}[Honest Subsequence]\label{lem.subsequence}
Consider any continuous window of $2k$ slots within an epoch. If \emph{any}
$k+1$ keys among these $2k$ are chosen, then at least one of them is guaranteed to
be honest, except with negligible probability in $k$
\end{lemma}

The proof of this lemma follows easily from the \emph{persistence} property of
Ouroboros~\cite{ouroboros} and is stated as Lemma $6$ in~\cite{pos-sidechains}).

\noindent
\emph{Merkle trees.} A Merkle tree~\cite{merkle} is a standard authenticated data structure
in which an array $d$ of data is organized into a binary tree. The data structure is built on
top of a secure hash function $H$. Initially, each leaf of data is hashed on its own. These hashes
form the leaves of the tree. Each odd-numbered leaf $h_1$ is then paired with its adjacent even-numbered
leaf $h_2$ and their values are concatenated and hashed together to form their parent
$h = H(h_1 \concat h_2)$. This process continues until we arrive at a single \emph{Merkle tree root} $\pi$.
If a verifier holds this root, a prover who wishes to illustrate that a leaf at a given index $i$
has a particular value $v$ simply provides the siblings $z$ along the path from the leaf to the root.
The verifier uses the function $\textsf{MT-verify}(\pi, v, i, z)$ these siblings to calculate a
new hash iteratively from the data until it
arrives at the root. Since the path is logarithmic in the count of the leaves, these proofs are
succinct ($|z| \in \mathcal{O}(\log |d|))$.
It is also possible to combine multiple proofs into one for efficiency. In that case,
the function $\textsf{MT-verify}(\pi, \overline{v}, \overline{i}, z)$ can accept an \emph{array} $\overline{v}$
of values, an \emph{array} $\overline{i}$ of indexes, and a combined proof $z$.
If $|v| \in \mathcal{O}(1)$, then $|z| \in \mathcal{\log|d|}$.
For the security of Merkle trees, only the \emph{collision resistance} property of hash
functions is needed (contrary to proof-of-work constructions, we can work in the \emph{standard model}
and do not model the hash function as a \emph{random oracle}). This ensures that no prover can
convincingly claim that a leaf is in a particular position in a tree that was constructed with different
data in that same position.

\noindent
\emph{Signatures.} We make use of standard secure signature schemes, with existential unforgeability.
Additionally, we require that the signature is \emph{unique}, meaning that
for each key and message, there exists a unique signature (and the signer cannot fake this).
Several signature schemes have this property~\cite{hash-and-sign,cramer2000signature}
and are constructible in the standard model~\cite{vrf,lysyanskaya-unique},
the most efficient of which are BLS signatures~\cite{bls}.
